/**
 * OAuth-Only Authentication Service
 * Focused exclusively on OAuth 2.0 SSO with MAX Platform integration
 * Enhanced with OAuth Infinite Loop Prevention
 */

import { PopupOAuthLogin, getUserInfo } from '../utils/popupOAuth';
import { attemptSilentLogin, isSafePageForTokenRefresh } from '../utils/silentAuth';
import { tokenRefreshManager } from './tokenRefreshManager';
import { tokenBlacklistService } from './tokenBlacklistService';
import { refreshTokenService, type TokenResponse } from './refreshTokenService';
import { browserSecurityCleanup } from '../utils/browserSecurityCleanup';
import { userIsolatedTokenStorage } from './userIsolatedTokenStorage';
import { securityHeaders } from './securityHeaders';
import type { User, MAXPlatformClaims } from '../types/auth';
import { jwtDecode } from 'jwt-decode';
import { oidcService } from './oidcService';
import { authSyncService } from './authSyncService';
import { useOAuthLoopPrevention, oauthLoopPrevention } from '../utils/oauthInfiniteLoopPrevention';
import { useAuthStore } from '../stores/authStore';
import { oauthRequestCoordinator } from './oauthRequestCoordinator';
import { SsoRefreshCircuitBreaker } from '../utils/ssoRefreshCircuitBreaker';

// Re-export for backward compatibility
export type IDTokenClaims = MAXPlatformClaims;

export interface AuthServiceResult {
  success: boolean;
  user?: User;
  error?: string;
}

export const authService = {
  /**
   * ÌåùÏóÖ OAuth Î°úÍ∑∏Ïù∏ (Enhanced with Loop Prevention through AuthStore)
   */
  loginWithPopupOAuth: async (forceAccountSelection = false): Promise<User> => {
    // Get authStore instance for integrated loop prevention
    const authStore = useAuthStore.getState();
    
    // Check if OAuth attempt should be allowed through authStore
    const attemptType = forceAccountSelection ? 'manual' : 'auto';
    const canAttempt = authStore.canAttemptOAuth(attemptType);
    
    if (!canAttempt.allowed) {
      console.warn('üö´ MaxLab OAuth attempt blocked by authStore loop prevention:', canAttempt.reason);
      
      // Set error state in authStore
      authStore.setAuthError({
        type: 'loop_prevention',
        message: canAttempt.reason || 'OAuth attempt blocked by loop prevention',
        recoverable: true,
        suggestion: canAttempt.suggestedAction
      });
      
      const error = new Error(canAttempt.reason + (canAttempt.suggestedAction ? `\n\nSuggested action: ${canAttempt.suggestedAction}` : ''));
      (error as any).blocked = true;
      (error as any).suggestion = canAttempt.suggestedAction;
      (error as any).waitTime = canAttempt.waitTime;
      throw error;
    }

    const oauthInstance = new PopupOAuthLogin();
    
    try {
      console.log(`üîê Starting popup OAuth login (force account selection: ${forceAccountSelection}, type: ${attemptType})...`);
      
      // üö® CRITICAL: Complete session cleanup for different user login
      if (forceAccountSelection) {
        console.log('üßπ Performing complete session cleanup for different user login...');
        
        // 1. Clear all existing tokens and auth state
        try {
          await refreshTokenService.clearAllTokens();
          console.log('‚úÖ Cleared refresh tokens');
        } catch (e) {
          console.warn('‚ö†Ô∏è Failed to clear refresh tokens:', e);
        }
        
        try {
          await userIsolatedTokenStorage.clearAllTokens();
          console.log('‚úÖ Cleared user isolated tokens');
        } catch (e) {
          console.warn('‚ö†Ô∏è Failed to clear user isolated tokens:', e);
        }
        
        // 2. Clear existing user data
        localStorage.removeItem('user');
        localStorage.removeItem('accessToken');
        localStorage.removeItem('hasLoggedOut');
        localStorage.removeItem('logoutTimestamp');
        console.log('‚úÖ Cleared localStorage user data');
        
        // 3. Force logout in auth store
        try {
          const { useAuthStore } = await import('../stores/authStore');
          useAuthStore.getState().logout();
          console.log('‚úÖ Forced auth store logout');
        } catch (e) {
          console.warn('‚ö†Ô∏è Failed to force auth store logout:', e);
        }
        
        // 4. Broadcast logout to other tabs before new login
        try {
          authSyncService.broadcastLogout();
          console.log('‚úÖ Broadcasted logout to other tabs');
        } catch (e) {
          console.warn('‚ö†Ô∏è Failed to broadcast logout:', e);
        }
        
        console.log('‚úÖ Complete session cleanup finished for different user login');
      }
      
      // üîß RACE CONDITION FIX: Queue OAuth popup request through coordinator
      const tokenResponse = await oauthRequestCoordinator.queueRequest(
        'authorize',
        'popup_oauth_auth',
        async (abortSignal) => {
          return await oauthInstance.startAuth(forceAccountSelection, abortSignal);
        },
        forceAccountSelection ? 1 : 0 // Higher priority for manual logins
      );
      
      // Record successful OAuth attempt
      oauthLoopPrevention.recordAttempt(attemptType, true);
      console.log('‚úÖ OAuth attempt successful - recorded in loop prevention system');
      console.log('‚úÖ Popup OAuth successful, getting user info...');
      
      const userInfo = await getUserInfo(tokenResponse.access_token);
      
      // ID Token Ï≤òÎ¶¨ (ÏûàÎäî Í≤ΩÏö∞)
      let idTokenClaims: MAXPlatformClaims | null = null;
      if (tokenResponse.id_token) {
        try {
          // ID Token ÎîîÏΩîÎìú Î∞è Í≤ÄÏ¶ù (OIDC service ÏÇ¨Ïö©)
          const storedNonce = sessionStorage.getItem('oauth_nonce');
          idTokenClaims = await oidcService.verifyIDToken(tokenResponse.id_token, storedNonce || undefined);
          console.log('‚úÖ ID Token validated:', idTokenClaims);
          
          // ID Token Ï†ÄÏû•
          sessionStorage.setItem('id_token', tokenResponse.id_token);
          
          // Nonce Ï†ïÎ¶¨
          if (storedNonce) {
            sessionStorage.removeItem('oauth_nonce');
          }
        } catch (error) {
          console.error('ID Token validation failed:', error);
          // ID Token Í≤ÄÏ¶ù Ïã§Ìå®Îäî Í≤ΩÍ≥†Îßå ÌïòÍ≥† Í≥ÑÏÜç ÏßÑÌñâ (ÌïòÏúÑ Ìò∏ÌôòÏÑ±)
        }
      }
      
      // ÌÜ†ÌÅ∞ Ï†ÄÏû• (RefreshTokenService ÏÇ¨Ïö©)
      await refreshTokenService.storeTokens({
        access_token: tokenResponse.access_token,
        token_type: tokenResponse.token_type || 'Bearer',
        expires_in: tokenResponse.expires_in,
        scope: tokenResponse.scope,
        refresh_token: tokenResponse.refresh_token,
        refresh_expires_in: tokenResponse.refresh_expires_in
      });
      
      // User-isolated token storageÏóêÎèÑ Ï†ÄÏû• (Ï∂îÍ∞Ä Î≥¥Ïïà)
      await userIsolatedTokenStorage.saveTokens({
        accessToken: tokenResponse.access_token,
        refreshToken: tokenResponse.refresh_token,
        idToken: tokenResponse.id_token,
        expiresAt: Date.now() + (tokenResponse.expires_in || 3600) * 1000
      }, idTokenClaims?.sub || userInfo.sub || userInfo.id || userInfo.email);
      
      console.log('üìã User info received:', userInfo);
      
      // ÏÇ¨Ïö©Ïûê Ï†ïÎ≥¥ Îß§Ìïë (ID Token claims Ïö∞ÏÑ†, UserInfo Ìè¥Î∞±)
      const user: User = {
        id: idTokenClaims?.sub || userInfo.sub || userInfo.id || userInfo.user_id || userInfo.email,
        email: idTokenClaims?.email || userInfo.email || '',
        username: idTokenClaims?.name || userInfo.name || userInfo.display_name || userInfo.username || userInfo.email || 'Unknown User',
        full_name: idTokenClaims?.name || userInfo.real_name || userInfo.full_name || userInfo.name || userInfo.display_name || userInfo.username || userInfo.email || 'Unknown User',
        is_active: userInfo.is_active !== undefined ? userInfo.is_active : true,
        is_admin: Boolean(idTokenClaims?.is_admin || userInfo.is_admin || userInfo.is_superuser || userInfo.admin),
        role: idTokenClaims?.role_name || idTokenClaims?.role || ((idTokenClaims?.is_admin || userInfo.is_admin || userInfo.is_superuser || userInfo.admin) ? 'admin' : 'user'),
        groups: idTokenClaims?.groups || (Array.isArray(userInfo.groups) 
          ? userInfo.groups.map((g: any) => typeof g === 'string' ? g : (g.name || g.display_name || g)).filter(Boolean)
          : [])
      };
      
      // Broadcast login event to other tabs
      authSyncService.broadcastLogin(user, tokenResponse.access_token);
      
      console.log('üë§ Mapped user:', user);
      
      // ÏÇ¨Ïö©Ïûê Ï†ïÎ≥¥ÏôÄ Ìï®Íªò ÏÉùÏÑ± ÏãúÍ∞Ñ Ï†ÄÏû•
      const currentTime = Date.now();
      const userWithMetadata = {
        ...user,
        created_at: currentTime,
        updated_at: currentTime
      };
      
      localStorage.setItem('user', JSON.stringify(userWithMetadata));
      
      // üîí CLEAR: Remove logout flags on successful login
      localStorage.removeItem('hasLoggedOut');
      localStorage.removeItem('logoutTimestamp');
      sessionStorage.removeItem('preventSilentAuth');
      console.log('üîì Cleared logout flags after successful login');
      
      // Record successful OAuth attempt through authStore
      authStore.recordOAuthAttempt(attemptType, true);
      
      return user;
      
    } catch (error: any) {
      console.error('Popup OAuth login error:', error);
      
      // Record failed OAuth attempt through authStore (automatically handles loop detection)
      authStore.recordOAuthAttempt(attemptType, false, error.message);
      
      // Check if infinite loop was detected (authStore handles this automatically)
      const loopDetection = authStore.detectInfiniteLoop();
      if (loopDetection.inLoop) {
        console.warn('üö® MaxLab OAuth infinite loop detected via authStore!', loopDetection);
        
        // Try automated recovery through authStore
        const recoveryActions = authStore.getOAuthRecoveryActions();
        const automatedAction = recoveryActions.find(action => action.automated);
        
        if (automatedAction) {
          console.log('üîÑ MaxLab: Attempting automated recovery:', automatedAction.action);
          const recoverySuccess = await oauthLoopPrevention.executeRecoveryAction(automatedAction.action);
          
          if (recoverySuccess) {
            console.log('‚úÖ MaxLab automated recovery successful');
          }
        }
        
        // Enhance error with loop information
        (error as any).infiniteLoop = true;
        (error as any).loopDetection = loopDetection;
        (error as any).recoveryActions = recoveryActions;
      }
      
      // Íµ¨Ï≤¥Ï†ÅÏù∏ ÏóêÎü¨ Î©îÏãúÏßÄ
      if (error.blocked) {
        // Error already processed by loop prevention
        throw error;
      } else if (error.message?.includes('blocked')) {
        throw new Error('Popup was blocked. Please allow popups for this site and try again.');
      } else if (error.message?.includes('cancelled')) {
        throw new Error('Login was cancelled by the user.');
      } else if (error.message?.includes('login_required')) {
        throw new Error('Please log in to MAX Platform first, then try OAuth login again.');
      } else if (error.message?.includes('aborted') || error.message?.includes('NS_BINDING_ABORTED')) {
        throw new Error('OAuth request was aborted. This might be due to a session mismatch. Please try clearing your browser cache and cookies, then try manual login.');
      } else {
        throw new Error('OAuth login failed. Please try again or contact support if the problem persists.');
      }
    } finally {
      oauthInstance.forceCleanup();
    }
  },

  /**
   * Silent SSO Î°úÍ∑∏Ïù∏ ÏãúÎèÑ
   */
  attemptSilentLogin: async (): Promise<AuthServiceResult> => {
    try {
      console.log('üîá Attempting silent SSO login...');
      
      // üîß RACE CONDITION FIX: Queue silent login request through coordinator
      const result = await oauthRequestCoordinator.queueRequest(
        'silent_login',
        'silent_oauth_auth',
        async (abortSignal) => {
          return await attemptSilentLogin(abortSignal);
        }
      );
      
      if (result.success && result.token) {
        console.log('‚úÖ Silent SSO login successful');
        
        // Record silent auth completion for grace period
        tokenBlacklistService.recordSilentAuthCompletion();
        
        const userInfo = await getUserInfo(result.token);
        
        // ÌÜ†ÌÅ∞ Ï†ÄÏû• (RefreshTokenService ÏÇ¨Ïö©)
        if (result.tokenData) {
          await refreshTokenService.storeTokens({
            access_token: result.token,
            token_type: result.tokenData.token_type || 'Bearer',
            expires_in: result.tokenData.expires_in || 3600,
            scope: result.tokenData.scope || 'read:profile read:groups manage:workflows',
            refresh_token: result.tokenData.refresh_token,
            refresh_expires_in: result.tokenData.refresh_expires_in
          });
        } else {
          // Fallback for when tokenData is not available
          await refreshTokenService.storeTokens({
            access_token: result.token,
            token_type: 'Bearer',
            expires_in: 3600,
            scope: 'read:profile read:groups manage:workflows'
          });
        }
        
        // User-isolated token storageÏóêÎèÑ Ï†ÄÏû• (Ï∂îÍ∞Ä Î≥¥Ïïà)
        await userIsolatedTokenStorage.saveTokens({
          accessToken: result.token,
          refreshToken: result.tokenData?.refresh_token,
          idToken: result.tokenData?.id_token,
          expiresAt: Date.now() + ((result.tokenData?.expires_in || 3600) * 1000)
        }, userInfo.sub || userInfo.id || userInfo.user_id || userInfo.email);
        
        // ÏÇ¨Ïö©Ïûê Ï†ïÎ≥¥ Îß§Ìïë (ÏïàÏ†ÑÌïú Í∏∞Î≥∏Í∞í Ï≤òÎ¶¨)
        const user: User = {
          id: userInfo.sub || userInfo.id || userInfo.user_id || userInfo.email,
          email: userInfo.email || '',
          username: userInfo.display_name || userInfo.username || userInfo.email || 'Unknown User',
          full_name: userInfo.real_name || userInfo.full_name || userInfo.display_name || userInfo.username || userInfo.email || 'Unknown User',
          is_active: userInfo.is_active !== undefined ? userInfo.is_active : true,
          is_admin: Boolean(userInfo.is_admin || userInfo.is_superuser || userInfo.admin),
          role: (userInfo.is_admin || userInfo.is_superuser || userInfo.admin) ? 'admin' : 'user',
          groups: Array.isArray(userInfo.groups) 
            ? userInfo.groups.map((g: any) => g.name || g.display_name || g).filter(Boolean)
            : []
        };
        
        // ÏÇ¨Ïö©Ïûê Ï†ïÎ≥¥ÏôÄ Ìï®Íªò ÏÉùÏÑ± ÏãúÍ∞Ñ Ï†ÄÏû•
        const currentTime = Date.now();
        const userWithMetadata = {
          ...user,
          created_at: currentTime,
          updated_at: currentTime
        };
        
        localStorage.setItem('user', JSON.stringify(userWithMetadata));
        
        // üîí CLEAR: Remove logout flags on successful silent login
        localStorage.removeItem('hasLoggedOut');
        localStorage.removeItem('logoutTimestamp');
        sessionStorage.removeItem('preventSilentAuth');
        console.log('üîì Cleared logout flags after successful silent login');
        
        return { success: true, user };
      } else {
        console.log('‚ÑπÔ∏è Silent SSO login failed:', result.error);
        return { 
          success: false, 
          error: result.error || 'Silent authentication failed' 
        };
      }
    } catch (error: any) {
      console.error('Silent login error:', error);
      return { 
        success: false, 
        error: error.message || 'Silent authentication failed' 
      };
    }
  },

  /**
   * ÌòÑÏû¨ ÏÇ¨Ïö©Ïûê Ï†ïÎ≥¥ Í∞ÄÏ†∏Ïò§Í∏∞
   */
  getCurrentUser: async (): Promise<User> => {
    const accessToken = localStorage.getItem('accessToken');
    if (!accessToken) {
      throw new Error('No access token available');
    }

    // ÌÜ†ÌÅ∞ Ïú†Ìö®ÏÑ± Î®ºÏ†Ä ÌôïÏù∏
    if (!authService.isAuthenticated()) {
      throw new Error('Token expired');
    }

    const userInfo = await getUserInfo(accessToken);
    const currentTime = Date.now();
    
    // ÏÇ¨Ïö©Ïûê Ï†ïÎ≥¥ Îß§Ìïë (ÏïàÏ†ÑÌïú Í∏∞Î≥∏Í∞í Ï≤òÎ¶¨)
    const user: User = {
      id: userInfo.sub || userInfo.id || userInfo.user_id || userInfo.email,
      email: userInfo.email || '',
      username: userInfo.display_name || userInfo.username || userInfo.email || 'Unknown User',
      full_name: userInfo.real_name || userInfo.full_name || userInfo.display_name || userInfo.username || userInfo.email || 'Unknown User',
      is_active: userInfo.is_active !== undefined ? userInfo.is_active : true,
      is_admin: Boolean(userInfo.is_admin || userInfo.is_superuser || userInfo.admin),
      role: (userInfo.is_admin || userInfo.is_superuser || userInfo.admin) ? 'admin' : 'user',
      groups: Array.isArray(userInfo.groups) 
        ? userInfo.groups.map((g: any) => g.name || g.display_name || g).filter(Boolean)
        : []
    };

    // ÏóÖÎç∞Ïù¥Ìä∏Îêú ÏÇ¨Ïö©Ïûê Ï†ïÎ≥¥ Ï†ÄÏû•
    const userWithMetadata = {
      ...user,
      created_at: JSON.parse(localStorage.getItem('user') || '{}').created_at || currentTime,
      updated_at: currentTime
    };
    
    localStorage.setItem('user', JSON.stringify(userWithMetadata));
    
    return user;
  },

  /**
   * ÌÜ†ÌÅ∞ Ïú†Ìö®ÏÑ± ÌôïÏù∏
   */
  validateToken: async (): Promise<boolean> => {
    try {
      const accessToken = localStorage.getItem('accessToken');
      if (!accessToken) {
        return false;
      }

      await getUserInfo(accessToken);
      return true;
    } catch (error) {
      console.error('Token validation failed:', error);
      return false;
    }
  },

  /**
   * Î°úÍ∑∏ÏïÑÏõÉ - Î°úÏª¨ ÏÑ∏ÏÖòÎßå Ï†ïÎ¶¨ (SSO ÏÑ∏ÏÖò Ïú†ÏßÄ)
   * @param options - Î°úÍ∑∏ÏïÑÏõÉ ÏòµÏÖò (useProviderLogout: OAuth ÏÑúÎ≤Ñ Î°úÍ∑∏ÏïÑÏõÉ Ïó¨Î∂Ä)
   */
  logout: async (options: { useProviderLogout?: boolean } = {}): Promise<void> => {
    try {
      const accessToken = localStorage.getItem('accessToken');
      
      // Step 1: üî• CRITICAL: Call backend logout API first (Redis ÏÑ∏ÏÖò Ï†ïÎ¶¨)
      if (accessToken) {
        try {
          const authUrl = import.meta.env.VITE_AUTH_SERVER_URL || 'http://localhost:8000';
          const response = await fetch(`${authUrl}/api/auth/logout`, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'Authorization': `Bearer ${accessToken}`
            }
          });
          
          if (response.ok) {
            const result = await response.json();
            console.log('‚úÖ Backend logout successful:', result.stats);
          } else {
            console.warn('‚ö†Ô∏è Backend logout failed:', response.status, response.statusText);
          }
        } catch (error) {
          console.warn('‚ö†Ô∏è Failed to call backend logout API:', error);
          // Continue with logout even if backend call fails
        }
      }
      
      // Step 2: Blacklist token on our backend (legacy)
      if (accessToken) {
        try {
          await tokenBlacklistService.blacklistCurrentToken('user_logout');
          console.log('‚úÖ Token blacklisted on backend');
        } catch (error) {
          console.warn('‚ö†Ô∏è Failed to blacklist token on backend:', error);
          // Continue with logout even if blacklisting fails
        }
      }
      
      // Step 3: üîí OAuth Provider Token Revocation (Ï°∞Í±¥Î∂Ä)
      // OAuth ÏÑúÎ≤ÑÏóê /api/oauth/logout ÏóîÎìúÌè¨Ïù∏Ìä∏Í∞Ä ÏóÜÏúºÎØÄÎ°ú ÌÜ†ÌÅ∞ revocationÎßå ÏàòÌñâ
      if (options.useProviderLogout !== false) { // Í∏∞Î≥∏Í∞íÏùÄ true (ÌïòÏúÑ Ìò∏ÌôòÏÑ±)
        try {
          const authUrl = import.meta.env.VITE_AUTH_SERVER_URL || 'http://localhost:8000';
          const clientId = import.meta.env.VITE_CLIENT_ID || 'maxlab';
          
          // ÌÜ†ÌÅ∞ revocationÎßå ÏàòÌñâ (logout ÏóîÎìúÌè¨Ïù∏Ìä∏ ÏÇ¨Ïö©ÌïòÏßÄ ÏïäÏùå)
          const accessToken = localStorage.getItem('accessToken');
          const refreshToken = localStorage.getItem('refreshToken');
          
          if (accessToken || refreshToken) {
            console.log('üîë Attempting token revocation...');
            
            // Access token revocation
            if (accessToken) {
              try {
                const response = await fetch(`${authUrl}/api/oauth/revoke`, {
                  method: 'POST',
                  headers: {
                    'Content-Type': 'application/x-www-form-urlencoded',
                  },
                  body: new URLSearchParams({
                    token: accessToken,
                    token_type_hint: 'access_token',
                    client_id: clientId
                  })
                });
                
                if (response.ok) {
                  console.log('‚úÖ Access token revoked');
                } else if (response.status === 404) {
                  console.log('‚ö†Ô∏è Token revocation endpoint not implemented (404) - continuing');
                }
              } catch (error) {
                console.warn('‚ö†Ô∏è Access token revocation failed:', error);
              }
            }
            
            // Refresh token revocation
            if (refreshToken) {
              try {
                const response = await fetch(`${authUrl}/api/oauth/revoke`, {
                  method: 'POST',
                  headers: {
                    'Content-Type': 'application/x-www-form-urlencoded',
                  },
                  body: new URLSearchParams({
                    token: refreshToken,
                    token_type_hint: 'refresh_token',
                    client_id: clientId
                  })
                });
                
                if (response.ok) {
                  console.log('‚úÖ Refresh token revoked');
                } else if (response.status === 404) {
                  console.log('‚ö†Ô∏è Token revocation endpoint not implemented (404) - continuing');
                }
              } catch (error) {
                console.warn('‚ö†Ô∏è Refresh token revocation failed:', error);
              }
            }
          }
          
          // Clear OAuth provider cookies
          const { clearOAuthProviderCookies } = await import('../utils/oauthProviderLogout');
          clearOAuthProviderCookies();
          console.log('üç™ OAuth provider cookies cleared');
          
        } catch (error) {
          console.error('‚ùå OAuth provider cleanup error:', error);
          // Continue with local logout even if OAuth provider cleanup fails
        }
      }
      
      // Step 4: Enhanced logout with refresh token revocation
      await refreshTokenService.secureLogout();
      
    } catch (error) {
      console.error('Logout error:', error);
      // Î°úÍ∑∏ÏïÑÏõÉ ÏóêÎü¨Îäî Î°úÍ∑∏Îßå ÎÇ®Í∏∞Í≥† Í≥ÑÏÜç ÏßÑÌñâ
    } finally {
      // Í∞ïÌôîÎêú Î°úÏª¨ Îç∞Ïù¥ÌÑ∞ Ï†ïÎ¶¨
      await authService._secureCleanup();
    }
  },

  /**
   * Î≥¥Ïïà Í∞ïÌôîÎêú Îç∞Ïù¥ÌÑ∞ Ï†ïÎ¶¨ - Comprehensive Browser Cleanup
   */
  _secureCleanup: async (): Promise<void> => {
    console.log('üîí Starting comprehensive security cleanup...');
    
    // ÌòÑÏû¨ ÌÜ†ÌÅ∞ÏùÑ Î∏îÎûôÎ¶¨Ïä§Ìä∏Ïóê Ï∂îÍ∞Ä
    const currentToken = localStorage.getItem('accessToken');
    if (currentToken) {
      tokenRefreshManager.blacklistToken(currentToken, 'logout');
    }

    // RefreshTokenServiceÎ•º ÌÜµÌïú ÏôÑÏ†ÑÌïú ÌÜ†ÌÅ∞ Ï†ïÎ¶¨
    await refreshTokenService.clearAllTokens();
    
    // User-isolated token storage Ï†ïÎ¶¨
    await userIsolatedTokenStorage.clearAllTokens();
    
    // Î≥¥Ïïà Ìó§Îçî ÏÑúÎπÑÏä§ ÏÑ∏ÏÖò ÌÜ†ÌÅ∞ Î¶¨ÏÖã
    securityHeaders.resetSessionToken();
    
    // Comprehensive browser security cleanup
    const cleanupResult = await browserSecurityCleanup.performSecurityCleanup({
      clearLocalStorage: true,
      clearSessionStorage: true,
      clearCookies: true,
      clearIndexedDB: true,
      clearCacheStorage: true,
      clearWebSQL: true,
      preserveKeys: ['theme', 'language', 'preferences'], // ÏÇ¨Ïö©Ïûê ÏÑ§Ï†ïÏùÄ Ïú†ÏßÄ
      cookieDomains: [window.location.hostname, '.localhost', 'localhost']
    });
    
    // üîí CRITICAL: Force clear all OAuth-related sessionStorage items
    const oauthKeys = [
      'oauth_state', 'oauth_code_verifier', 'oauth_nonce', 
      'oauth_popup_mode', 'oauth_window_type', 'oauth_parent_origin',
      'oauth_result', 'oauth_error', 'oauth_force_account_selection',
      'silent_oauth_state', 'silent_oauth_code_verifier',
      'oauth_flow_in_progress', 'oauth_callback_processing'
    ];
    oauthKeys.forEach(key => sessionStorage.removeItem(key));
    
    if (cleanupResult.success) {
      console.log('‚úÖ Security cleanup completed:', {
        localStorage: cleanupResult.cleared.localStorage,
        sessionStorage: cleanupResult.cleared.sessionStorage,
        cookies: cleanupResult.cleared.cookies,
        indexedDB: cleanupResult.cleared.indexedDB.length,
        cacheStorage: cleanupResult.cleared.cacheStorage.length,
        duration: `${cleanupResult.duration.toFixed(2)}ms`
      });
    } else {
      console.error('‚ùå Security cleanup encountered errors:', cleanupResult.errors);
    }
    
    // Ï∂îÍ∞Ä Î≥¥Ïïà Ï°∞Ïπò: Î™®Îì† Ïù¥Î≤§Ìä∏ Î¶¨Ïä§ÎÑà Ï†ïÎ¶¨
    window.dispatchEvent(new CustomEvent('auth:cleanup_complete', { 
      detail: { cleanupResult } 
    }));
    
    console.log('üßπ Complete secure cleanup finished');
  },

  /**
   * Ïù∏Ï¶ù ÏÉÅÌÉú ÌôïÏù∏ - Î≥¥Ïïà Í∞ïÌôî
   */
  isAuthenticated: (): boolean => {
    const accessToken = localStorage.getItem('accessToken');
    const tokenExpiryTime = localStorage.getItem('tokenExpiryTime');
    
    if (!accessToken) {
      return false;
    }

    // ÌÜ†ÌÅ∞ Î∏îÎûôÎ¶¨Ïä§Ìä∏ ÌôïÏù∏
    if (tokenRefreshManager.isTokenBlacklisted(accessToken)) {
      console.log('üö´ Token is blacklisted, clearing storage');
      authService._secureCleanup();
      return false;
    }
    
    // ÌÜ†ÌÅ∞ ÎßåÎ£å ÌôïÏù∏ (Ï†ïÌôïÌïú ÎßåÎ£å ÏãúÍ∞Ñ ÏÇ¨Ïö©)
    if (tokenExpiryTime) {
      const expiryTime = parseInt(tokenExpiryTime, 10);
      const now = Date.now();
      
      // üîí CRITICAL FIX: Only return true if access token is ACTUALLY valid
      if (now >= expiryTime) {
        console.log('Access token expired');
        tokenRefreshManager.blacklistToken(accessToken, 'expired');
        
        // üîí SECURITY: Do NOT return true for expired tokens
        // The token refresh logic should handle renewal separately
        return false;
      }
    }
    
    // Ï†ÄÏû•Îêú ÏÇ¨Ïö©Ïûê Ï†ïÎ≥¥ ÌôïÏù∏
    const storedUser = authService.getStoredUser();
    if (!storedUser || !storedUser.id) {
      console.log('No valid user data found');
      return false;
    }
    
    return true;
  },

  /**
   * Ï†ÄÏû•Îêú ÏÇ¨Ïö©Ïûê Ï†ïÎ≥¥ Í∞ÄÏ†∏Ïò§Í∏∞
   */
  getStoredUser: (): User | null => {
    const userStr = localStorage.getItem('user');
    return userStr ? JSON.parse(userStr) : null;
  },

  /**
   * ÌöåÏõêÍ∞ÄÏûÖ Î¶¨Îã§Ïù¥Î†âÌä∏
   */
  redirectToSignup: (): void => {
    const authUrl = import.meta.env.VITE_AUTH_SERVER_URL || 'http://localhost:8000';
    const signupUrl = authUrl.replace(':8000', ':3000'); // MAX Platform frontend
    window.location.href = `${signupUrl}/signup?redirect=${encodeURIComponent(window.location.origin)}`;
  },

  /**
   * Ïù∏Ï¶ù ÌÜ†ÌÅ∞ Í∞±Ïã† - Refresh Token Ïö∞ÏÑ†, Silent Auth Ìè¥Î∞±
   */
  refreshToken: async (forceRefresh: boolean = false): Promise<boolean> => {
    return tokenRefreshManager.refreshToken(async () => {
      try {
        console.log('üîÑ Attempting token refresh with fallback chain...');
        
        // CHECK: Is this an SSO-synced session without refresh tokens?
        const authMethod = localStorage.getItem('auth_method');
        const hasRefreshToken = localStorage.getItem('has_refresh_token') === 'true';
        const maxPlatformSession = localStorage.getItem('max_platform_session') === 'true';
        const tokenRenewableViaSso = localStorage.getItem('token_renewable_via_sso') === 'true';
        
        // üö® CRITICAL FIX: Use circuit breaker for SSO refresh failures
        const ssoRefreshAttempt = SsoRefreshCircuitBreaker.canAttemptSsoRefresh();
        
        if (authMethod === 'sso_sync' && !hasRefreshToken && maxPlatformSession && tokenRenewableViaSso && ssoRefreshAttempt.allowed) {
          console.log('üîÑ SSO Session: Attempting token refresh via MAX Platform redirect...');
          
          // üîí CRITICAL: Cancel any pending silent auth attempts to prevent conflicts
          try {
            const cancelledCount = oauthRequestCoordinator.cancelRequestsByType('silent_login');
            if (cancelledCount > 0) {
              console.log(`‚úÖ Cancelled ${cancelledCount} pending silent auth requests before SSO refresh`);
            }
          } catch (e) {
            console.warn('‚ö†Ô∏è Failed to cancel silent auth requests:', e);
          }
          
          // CRITICAL FIX: Validate session state before attempting SSO refresh
          // Check if we recently failed an SSO refresh (within last 30 seconds)
          const lastSsoFailure = sessionStorage.getItem('last_sso_failure');
          if (lastSsoFailure) {
            const failureTime = parseInt(lastSsoFailure);
            const timeSinceFailure = Date.now() - failureTime;
            const thirtySeconds = 30 * 1000;
            
            if (timeSinceFailure < thirtySeconds) {
              console.log('üö® Recent SSO failure detected, blocking retry for', Math.ceil((thirtySeconds - timeSinceFailure) / 1000), 'seconds');
              return {
                success: false,
                error: 'Recent SSO failure - please wait before retrying'
              };
            }
          }
          
          // üîß FIX: Use unified SSO circuit breaker instead of duplicate logic
          // Check SSO circuit breaker status (already checked above, but ensure it's current)
          if (!ssoRefreshAttempt.allowed) {
            console.log(`üö® SSO refresh blocked by circuit breaker: ${ssoRefreshAttempt.reason}`);
            // Clear SSO metadata to break potential loops
            localStorage.removeItem('auth_method');
            localStorage.removeItem('max_platform_session');
            localStorage.removeItem('token_renewable_via_sso');
            sessionStorage.setItem('preventSilentAuth', 'true');
            return {
              success: false,
              error: ssoRefreshAttempt.reason || 'Too many authentication attempts - please login manually'
            };
          }
          
          // For SSO sessions, redirect to MAX Platform for token refresh
          try {
            const currentOrigin = window.location.origin;
            const redirectUri = `${currentOrigin}/oauth/callback`;
            const backendUrl = import.meta.env.VITE_API_BASE_URL || 'http://localhost:8010';
            
            // üîí CRITICAL FIX: Validate return URL before saving
            // Don't save error callback URLs as return URLs - this causes infinite loops!
            let returnUrl = window.location.href;
            const currentUrl = new URL(returnUrl);
            
            // üîß CRITICAL FIX: Check if current URL is ANY OAuth callback (success OR error)
            const isAnyOAuthCallback = currentUrl.pathname === '/oauth/callback' && 
                                     (currentUrl.searchParams.has('code') || 
                                      currentUrl.searchParams.has('error') || 
                                      currentUrl.searchParams.has('error_description') ||
                                      currentUrl.searchParams.has('state'));
                                      
            // üîß ENHANCED: Extra check for SSO refresh loops
            const isSSORrefreshCallback = currentUrl.searchParams.get('state')?.startsWith('sso_refresh_');
            
            if (isAnyOAuthCallback) {
              if (isSSORrefreshCallback) {
                console.log('üö® CRITICAL: SSO refresh callback detected as current URL - this would cause infinite redirect loop!');
              } else {
                console.log('‚ö†Ô∏è Current URL is OAuth callback, using safe fallback to prevent infinite redirect');
              }
              
              // üîß ENHANCED: Multiple fallback strategies for return URL
              const storedOriginalUrl = sessionStorage.getItem('original_navigation_url') || 
                                       localStorage.getItem('pre_auth_url');
                                       
              // Additional fallback: check referrer if available and safe
              let fallbackUrl = storedOriginalUrl;
              if (!fallbackUrl && document.referrer) {
                const referrerUrl = new URL(document.referrer);
                // Only use referrer if it's from the same origin and not an auth page
                const isReferrerSafe = referrerUrl.origin === currentOrigin && 
                                     !referrerUrl.pathname.includes('/oauth/') &&
                                     !referrerUrl.pathname.includes('/login');
                if (isReferrerSafe) {
                  fallbackUrl = document.referrer;
                  console.log('üìç Using referrer as fallback return URL');
                }
              }
              
              returnUrl = fallbackUrl || `${currentOrigin}/dashboard`;
              console.log('‚úÖ Using safe return URL:', returnUrl);
            }
            
            // Store the safe return URL
            const returnData = {
              url: returnUrl,
              timestamp: Date.now(),
              attempt: 'sso_refresh'
            };
            localStorage.setItem('sso_refresh_return_data', JSON.stringify(returnData));
            sessionStorage.setItem('sso_refresh_return_url', returnUrl); // Keep for backward compatibility
            
            // Add state parameter to track this is an SSO refresh attempt
            const state = `sso_refresh_${Date.now()}`;
            
            // üîí CRITICAL FIX: Create OAuth flow state for SSO refresh
            // This ensures the OAuth callback can validate the state properly
            try {
              const { createOAuthFlow } = await import('../utils/oauthStateManager');
              
              // Generate required OAuth parameters for SSO refresh
              const codeVerifier = authService.generateCodeVerifier();
              const nonce = authService.generateNonce();
              
              createOAuthFlow({
                flowType: 'redirect',
                clientId: import.meta.env.VITE_CLIENT_ID || 'maxlab',
                redirectUri: redirectUri,
                state: state,
                codeVerifier: codeVerifier,
                nonce: nonce,
                expiryMs: 10 * 60 * 1000 // 10 minutes for SSO refresh
              });
              
              console.log('‚úÖ OAuth flow state created for SSO refresh:', state.substring(0, 16) + '...');
            } catch (stateError) {
              console.error('‚ùå Failed to create OAuth flow state for SSO refresh:', stateError);
              // Continue without state manager - legacy fallback
            }
            
            const ssoRefreshUrl = `${backendUrl}/oauth/sso-token-refresh?redirect_uri=${encodeURIComponent(redirectUri)}&state=${state}`;
            
            console.log('üîÑ SSO Session: Redirecting to SSO token refresh endpoint...');
            console.log('üìç Return URL saved:', returnUrl);
            
            // Record attempt time to prevent rapid retries
            sessionStorage.setItem('last_sso_attempt', Date.now().toString());
            
            // üîß REMOVED: Duplicate SSO attempt tracking - now using unified SsoRefreshCircuitBreaker
            
            // Redirect to SSO token refresh endpoint
            window.location.href = ssoRefreshUrl;
            
            // This won't return, but we provide a success response for consistency
            return {
              success: true,
              redirecting: true,
              message: 'Redirecting to MAX Platform for token refresh'
            };
          } catch (ssoError: any) {
            console.error('‚ùå SSO token refresh failed:', ssoError);
            
            // Record SSO refresh failure in circuit breaker
            SsoRefreshCircuitBreaker.recordFailure(ssoError.message || 'SSO redirect failed');
            
            // Fall back to silent auth if SSO refresh fails
            console.log('üîÑ SSO refresh failed, falling back to silent auth...');
          }
        } else if (!ssoRefreshAttempt.allowed) {
          console.log(`üö® SSO refresh blocked by circuit breaker: ${ssoRefreshAttempt.reason}`);
          console.log(`üïí Next attempt allowed in: ${ssoRefreshAttempt.nextAttemptIn || 0} seconds`);
          
          // Circuit breaker automatically handles SSO metadata cleanup
        }
        
        // 1Ï∞®: Refresh Token ÏãúÎèÑ (for non-SSO sessions or SSO with refresh tokens)
        const hasValidRefreshToken = await refreshTokenService.isRefreshTokenValidAsync();
        if (hasValidRefreshToken) {
          try {
            console.log('üéüÔ∏è Attempting refresh with refresh token...');
            const refreshResult = await refreshTokenService.refreshWithRefreshToken();
            
            // ÌÜ†ÌÅ∞ Í∞±Ïã† ÏÑ±Í≥µ Ïãú ÏÇ¨Ïö©Ïûê Ï†ïÎ≥¥ÎèÑ ÏóÖÎç∞Ïù¥Ìä∏
            const userInfo = await getUserInfo(refreshResult.access_token);
            const user: User = {
              id: userInfo.sub || userInfo.id || userInfo.user_id || userInfo.email,
              email: userInfo.email || '',
              username: userInfo.name || userInfo.display_name || userInfo.username || userInfo.email || 'Unknown User',
              full_name: userInfo.real_name || userInfo.full_name || userInfo.name || userInfo.display_name || userInfo.username || userInfo.email || 'Unknown User',
              is_active: userInfo.is_active !== undefined ? userInfo.is_active : true,
              is_admin: Boolean(userInfo.is_admin || userInfo.is_superuser || userInfo.admin),
              role: (userInfo.is_admin || userInfo.is_superuser || userInfo.admin) ? 'admin' : 'user',
              groups: Array.isArray(userInfo.groups) 
                ? userInfo.groups.map((g: any) => typeof g === 'string' ? g : (g.name || g.display_name || g)).filter(Boolean)
                : []
            };
            
            // ÏÇ¨Ïö©Ïûê Ï†ïÎ≥¥ ÏóÖÎç∞Ïù¥Ìä∏
            const currentTime = Date.now();
            const userWithMetadata = {
              ...user,
              created_at: JSON.parse(localStorage.getItem('user') || '{}').created_at || currentTime,
              updated_at: currentTime
            };
            
            localStorage.setItem('user', JSON.stringify(userWithMetadata));
            
            console.log('‚úÖ Refresh token renewal successful');
            
            // Reset SSO circuit breaker on successful token refresh
            SsoRefreshCircuitBreaker.recordSuccess();
            
            return {
              success: true,
              token: refreshResult.access_token
            };
          } catch (refreshError: any) {
            console.warn('‚ö†Ô∏è Refresh token failed, falling back to silent auth:', refreshError.message);
            
            // 401 Ïò§Î•òÏù∏ Í≤ΩÏö∞ ÌäπÎ≥ÑÌïú Ï≤òÎ¶¨
            if (refreshError.message === 'refresh_token_invalid') {
              console.error('üîí Refresh token is invalid - likely expired or revoked');
              
              // ÏÇ¨Ïö©ÏûêÏóêÍ≤å ÏïåÎ¶º Ïù¥Î≤§Ìä∏ Î∞úÏÜ°
              window.dispatchEvent(new CustomEvent('auth:refresh_token_invalid', {
                detail: { 
                  message: 'Your session has expired. Please log in again.',
                  reason: 'refresh_token_invalid',
                  action: 'login_required'
                }
              }));
            }
            // Îã§Ïùå Îã®Í≥ÑÎ°ú ÏßÑÌñâ
          }
        }
        
        // 2Ï∞®: Silent Auth Ìè¥Î∞±
        // CRITICAL FIX: Check circuit breaker before attempting silent auth
        const circuitStatus = SsoRefreshCircuitBreaker.canAttemptSsoRefresh();
        if (!circuitStatus.allowed) {
          console.log('üö® Silent auth blocked by SSO circuit breaker:', circuitStatus.reason);
          console.log(`üïí Circuit breaker will reset in ${circuitStatus.nextAttemptIn} seconds`);
          
          // Clear all SSO metadata to prevent loops
          localStorage.removeItem('auth_method');
          localStorage.removeItem('max_platform_session');
          localStorage.removeItem('token_renewable_via_sso');
          
          return {
            success: false,
            error: 'SSO circuit breaker is open - authentication required'
          };
        }
        
        if (isSafePageForTokenRefresh()) {
          console.log('üîá Falling back to silent authentication...');
          const result = await authService.attemptSilentLogin();
          
          if (result.success) {
            console.log('‚úÖ Silent auth fallback successful');
            
            // Reset SSO circuit breaker on successful silent auth
            SsoRefreshCircuitBreaker.recordSuccess();
            
            return {
              success: true,
              token: localStorage.getItem('accessToken') || undefined
            };
          } else {
            console.log('‚ùå Silent auth fallback failed:', result.error);
            
            // If both refresh and silent auth fail, and this was an SSO session, clear metadata
            const authMethod = localStorage.getItem('auth_method');
            if (authMethod === 'sso_sync') {
              console.log('üö® SSO session completely failed, clearing all SSO metadata');
              localStorage.removeItem('auth_method');
              localStorage.removeItem('has_refresh_token');
              localStorage.removeItem('max_platform_session');
              localStorage.removeItem('token_renewable_via_sso');
              localStorage.removeItem('sync_time');
            }
            
            return {
              success: false,
              error: result.error || 'Both refresh token and silent auth failed'
            };
          }
        } else {
          console.log('‚ùå Current page not safe for silent auth, refresh completely failed');
          return {
            success: false,
            error: 'Refresh token failed and silent auth not available on current page'
          };
        }
      } catch (error: any) {
        console.error('‚ùå Complete token refresh chain failed:', error);
        return {
          success: false,
          error: error.message || 'Token refresh chain failed'
        };
      }
    }, { forceRefresh });
  },

  /**
   * ÏûêÎèô ÌÜ†ÌÅ∞ Í∞±Ïã† ÏãúÏûë - ÏµúÏ†ÅÌôîÎêú Î°úÏßÅ
   */
  startAutoTokenRefresh: (): (() => void) => {
    let refreshInterval: NodeJS.Timeout;
    let lastRefreshAttempt = 0;
    let consecutiveFailures = 0;
    let lastError: string | null = null;
    
    // Ï∞®Îì±Ï†Å Ïû¨ÏãúÎèÑ Ï†ïÏ±Ö: Ïò§Î•ò Ïú†ÌòïÏóê Îî∞Î•∏ maxRetries Í≤∞Ï†ï
    const getMaxRetries = (errorType: string, errorMessage?: string): number => {
      let maxRetries = 3; // Í∏∞Î≥∏Í∞í
      let reason = 'default policy';
      
      if (errorType === 'NETWORK_ERROR' || 
          errorMessage?.includes('Network Error') ||
          errorMessage?.includes('ERR_NETWORK') ||
          errorMessage?.includes('timeout') ||
          errorMessage?.includes('connection')) {
        maxRetries = 5; // ÎÑ§Ìä∏ÏõåÌÅ¨ Ïò§Î•òÎäî Îçî Í¥ÄÎåÄÌïòÍ≤å
        reason = 'network error - more tolerant retry policy';
      } else if (errorType === 'INVALID_REFRESH_TOKEN' ||
                 errorMessage?.includes('refresh_token_invalid') ||
                 errorMessage?.includes('refresh_token_expired') ||
                 errorMessage?.includes('invalid_token') ||
                 errorMessage?.includes('401')) {
        maxRetries = 1; // ÌÜ†ÌÅ∞ Ïò§Î•òÎäî Ï¶âÏãú Ï≤òÎ¶¨
        reason = 'token error - immediate failure policy';
      } else if (errorMessage?.includes('403') || errorMessage?.includes('forbidden')) {
        maxRetries = 1; // Í∂åÌïú Ïò§Î•òÎäî Ï¶âÏãú Ï≤òÎ¶¨
        reason = 'permission error - immediate failure policy';
      } else if (errorMessage?.includes('500') || errorMessage?.includes('502') || errorMessage?.includes('503')) {
        maxRetries = 4; // ÏÑúÎ≤Ñ Ïò§Î•òÎäî Ï§ëÍ∞Ñ Ï†ïÎèÑ
        reason = 'server error - moderate retry policy';
      }
      
      console.log(`üìã Max retries set to ${maxRetries} (${reason}) for error: ${errorMessage || errorType}`);
      return maxRetries;
    };
    
    const checkAndRefresh = async () => {
      try {
        if (!authService.isAuthenticated()) {
          console.log('üîì User not authenticated, stopping auto refresh');
          clearInterval(refreshInterval);
          return;
        }

        // ÌòÑÏû¨ ÌéòÏù¥ÏßÄÏóêÏÑú ÌÜ†ÌÅ∞ Í∞±Ïã†Ïù¥ ÏïàÏ†ÑÌïúÏßÄ ÌôïÏù∏
        if (!isSafePageForTokenRefresh()) {
          console.log('üîê Current page not safe for token refresh, skipping...');
          return;
        }

        // ÌÜ†ÌÅ∞ Í∞±Ïã† ÌïÑÏöî Ïó¨Î∂Ä ÌôïÏù∏
        const needsRefresh = authService.needsTokenRefresh();
        const hasValidRefreshToken = refreshTokenService.isRefreshTokenValid();
        
        if (needsRefresh) {
          // ÎÑàÎ¨¥ ÎπàÎ≤àÌïú Í∞±Ïã† ÏãúÎèÑ Î∞©ÏßÄ (30Ï¥à Ïø®Îã§Ïö¥)
          const now = Date.now();
          if (now - lastRefreshAttempt < 30000) {
            console.log('üîÑ Token refresh attempted too recently, skipping...');
            return;
          }

          lastRefreshAttempt = now;
          
          console.log(`üîÑ Token needs refresh, attempting automatic refresh... (Method: ${hasValidRefreshToken ? 'refresh_token' : 'silent_auth'})`);
          
          const success = await authService.refreshToken();
          
          if (success) {
            console.log('‚úÖ Auto token refresh successful');
            consecutiveFailures = 0; // ÏÑ±Í≥µ Ïãú Ïã§Ìå® Ïπ¥Ïö¥ÌÑ∞ Î¶¨ÏÖã
            lastError = null; // ÏóêÎü¨ Ï†ïÎ≥¥ Î¶¨ÏÖã
          } else {
            consecutiveFailures++;
            const currentError = lastError || 'unknown_error';
            
            // Ï∞®Îì±Ï†Å Ïû¨ÏãúÎèÑ Ï†ïÏ±Ö Ï†ÅÏö©
            const maxRetries = getMaxRetries('UNKNOWN', currentError);
            
            console.log(`‚ùå Auto token refresh failed (attempt ${consecutiveFailures}/${maxRetries})`);
            console.log(`üìä Last error type: ${currentError}`);
            
            // ÎèôÏ†Å Ïã§Ìå® ÏûÑÍ≥ÑÍ∞íÏóê ÎèÑÎã¨ Ïãú Î°úÍ∑∏ÏïÑÏõÉ
            if (consecutiveFailures >= maxRetries) {
              console.log(`‚ùå Reached maximum retries (${maxRetries}) for error type, logging out user`);
              console.log(`üìä Failure pattern: ${maxRetries} consecutive failures with error: ${currentError}`);
              clearInterval(refreshInterval);
              
              // ÏûêÎèô Î°úÍ∑∏ÏïÑÏõÉ ÏàòÌñâ
              await authService.logout();
              
              // Î°úÍ∑∏Ïù∏ ÌéòÏù¥ÏßÄÎ°ú Î¶¨Îã§Ïù¥Î†âÌä∏ (Ïï± ÏàòÏ§ÄÏóêÏÑú Ï≤òÎ¶¨ÎêòÎèÑÎ°ù Ïù¥Î≤§Ìä∏ Î∞úÏÜ°)
              window.dispatchEvent(new CustomEvent('auth:logout', { 
                detail: { 
                  reason: 'token_refresh_failed', 
                  attempts: consecutiveFailures,
                  maxRetries: maxRetries,
                  lastError: currentError
                } 
              }));
              return;
            }
          }
        } else {
          // Í∞±Ïã†Ïù¥ ÌïÑÏöîÌïòÏßÄ ÏïäÏúºÎ©¥ Ïã§Ìå® Ïπ¥Ïö¥ÌÑ∞ Î¶¨ÏÖã
          if (consecutiveFailures > 0) {
            console.log('üîÑ Token refresh no longer needed, resetting failure counter');
            consecutiveFailures = 0;
            lastError = null;
          }
        }

        // Refresh Token ÎßåÎ£å ÏûÑÎ∞ï ÏïåÎ¶º (1Ïùº Ï†Ñ)
        if (hasValidRefreshToken && refreshTokenService.needsRefreshTokenRenewal()) {
          console.log('‚ö†Ô∏è Refresh token expires soon, user should re-authenticate');
          window.dispatchEvent(new CustomEvent('auth:refresh_token_expiring', {
            detail: { 
              timeToExpiry: refreshTokenService.getRefreshTokenTimeToExpiry(),
              message: 'Your session will expire soon. Please log in again to maintain access.'
            }
          }));
        }

      } catch (error) {
        console.error('Auto token refresh check error:', error);
        const errorMessage = error instanceof Error ? error.message : String(error);
        lastError = errorMessage;
        consecutiveFailures++;
        
        // Ï∞®Îì±Ï†Å Ïû¨ÏãúÎèÑ Ï†ïÏ±Ö Ï†ÅÏö©
        const maxRetries = getMaxRetries('CRITICAL_ERROR', errorMessage);
        
        console.log(`‚ùå Critical error in token refresh (attempt ${consecutiveFailures}/${maxRetries}):`, errorMessage);
        
        // ÎèôÏ†Å Ïã§Ìå® ÏûÑÍ≥ÑÍ∞íÏóê ÎèÑÎã¨ Ïãú Î°úÍ∑∏ÏïÑÏõÉ
        if (consecutiveFailures >= maxRetries) {
          console.log(`‚ùå Reached maximum retries (${maxRetries}) for critical error, forcing logout`);
          console.log(`üìä Critical error pattern: ${maxRetries} consecutive failures with error: ${errorMessage}`);
          clearInterval(refreshInterval);
          await authService.logout();
          window.dispatchEvent(new CustomEvent('auth:logout', { 
            detail: { 
              reason: 'critical_error', 
              error: errorMessage,
              attempts: consecutiveFailures,
              maxRetries: maxRetries
            } 
          }));
        }
      }
    };

    // ÎèôÏ†Å Ïù∏ÌÑ∞Î≤å ÏÑ§Ï†ï
    const getRefreshInterval = () => {
      const accessTokenTimeToExpiry = authService.getTokenTimeToExpiry();
      
      // Access token ÎßåÎ£åÍπåÏßÄ 5Î∂Ñ Ïù¥ÌïòÎ©¥ 30Ï¥àÎßàÎã§ Ï≤¥ÌÅ¨
      if (accessTokenTimeToExpiry <= 300) {
        return 30 * 1000; // 30Ï¥à
      }
      
      // Access token ÎßåÎ£åÍπåÏßÄ 30Î∂Ñ Ïù¥ÌïòÎ©¥ 1Î∂ÑÎßàÎã§ Ï≤¥ÌÅ¨
      if (accessTokenTimeToExpiry <= 1800) {
        return 60 * 1000; // 1Î∂Ñ
      }
      
      // Í∑∏ Ïô∏Ïùò Í≤ΩÏö∞ 5Î∂ÑÎßàÎã§ Ï≤¥ÌÅ¨
      return 5 * 60 * 1000; // 5Î∂Ñ
    };

    // Ï¥àÍ∏∞ Ï≤¥ÌÅ¨
    checkAndRefresh();

    // ÎèôÏ†Å Ïù∏ÌÑ∞Î≤åÎ°ú Í∞±Ïã† Ï≤¥ÌÅ¨
    const startDynamicInterval = () => {
      const interval = getRefreshInterval();
      refreshInterval = setTimeout(() => {
        checkAndRefresh().then(() => {
          startDynamicInterval(); // Ïû¨Í∑ÄÏ†ÅÏúºÎ°ú Îã§Ïùå Ïù∏ÌÑ∞Î≤å ÏÑ§Ï†ï
        });
      }, interval);
    };

    startDynamicInterval();

    // Ï†ïÎ¶¨ Ìï®Ïàò Î∞òÌôò
    return () => {
      if (refreshInterval) {
        clearTimeout(refreshInterval);
      }
    };
  },

  /**
   * ÏÇ¨Ïö©Ïûê Í∂åÌïú ÌôïÏù∏
   */
  hasPermission: (requiredRole: 'admin' | 'user' = 'user'): boolean => {
    const user = authService.getStoredUser();
    if (!user) return false;
    
    if (requiredRole === 'admin') {
      return user.is_admin || false;
    }
    
    return true; // All authenticated users have 'user' permission
  },

  /**
   * ÌÜ†ÌÅ∞ Í∞±Ïã† ÌïÑÏöî Ïó¨Î∂Ä ÌôïÏù∏ - Refresh Token Í≥†Î†§
   */
  needsTokenRefresh: (): boolean => {
    const accessToken = localStorage.getItem('accessToken');
    const tokenExpiryTime = localStorage.getItem('tokenExpiryTime');
    
    if (!accessToken || !tokenExpiryTime) {
      return false;
    }

    // ÏµúÍ∑º Í∞±Ïã† ÏãúÍ∞Ñ ÌôïÏù∏ (OAuth ÏΩúÎ∞± Ï§ë Ï§ëÎ≥µ Í∞±Ïã† Î∞©ÏßÄ)
    const lastRefresh = localStorage.getItem('lastTokenRefresh');
    if (lastRefresh && (Date.now() - parseInt(lastRefresh)) < 30000) {
      return false;
    }
    
    const expiryTime = parseInt(tokenExpiryTime, 10);
    const now = Date.now();
    const bufferTime = 5 * 60 * 1000; // 5 minutes
    
    // Access tokenÏù¥ Í∞±Ïã†Ïù¥ ÌïÑÏöîÌïú ÏãúÏ†êÏù¥Í≥†, refresh tokenÏù¥ÎÇò Îã§Î•∏ Í∞±Ïã† Î∞©Î≤ïÏù¥ ÏûàÎäî Í≤ΩÏö∞
    const needsRefresh = now >= (expiryTime - bufferTime);
    
    if (needsRefresh) {
      // ÌÜ†ÌÅ∞ Í∞±Ïã†Ïù¥ ÏïàÏ†ÑÌïú ÌôòÍ≤ΩÏù∏ÏßÄ Î®ºÏ†Ä ÌôïÏù∏
      const canUseSilentAuth = isSafePageForTokenRefresh();
      
      if (!canUseSilentAuth) {
        console.log('üö´ Token refresh not safe in current context, skipping');
        return false;
      }

      // Refresh tokenÏù¥ Ïú†Ìö®ÌïòÍ±∞ÎÇò silent auth Í∞ÄÎä•Ìïú Í≤ΩÏö∞ Í∞±Ïã† ÏãúÎèÑ
      const hasValidRefreshToken = refreshTokenService.isRefreshTokenValid();
      
      console.log('üîÑ Token refresh eligibility check:', {
        needsRefresh,
        hasValidRefreshToken,
        canUseSilentAuth,
        timeToExpiry: authService.getTokenTimeToExpiry()
      });
      
      return hasValidRefreshToken || canUseSilentAuth;
    }
    
    return false;
  },

  /**
   * ÌÜ†ÌÅ∞ ÎßåÎ£åÍπåÏßÄ ÎÇ®ÏùÄ ÏãúÍ∞Ñ (Ï¥à)
   */
  getTokenTimeToExpiry: (): number => {
    const tokenExpiryTime = localStorage.getItem('tokenExpiryTime');
    
    if (!tokenExpiryTime) {
      return 0;
    }
    
    const expiryTime = parseInt(tokenExpiryTime, 10);
    const now = Date.now();
    
    return Math.max(0, Math.floor((expiryTime - now) / 1000));
  },

  /**
   * ÎîîÎ≤ÑÍπÖ Ï†ïÎ≥¥ - Refresh Token Ï†ïÎ≥¥ Ìè¨Ìï®
   */
  getAuthDebugInfo: () => {
    const tokenExpiryTime = localStorage.getItem('tokenExpiryTime');
    const tokenCreatedAt = localStorage.getItem('tokenCreatedAt');
    const refreshTokenDebug = refreshTokenService.getDebugInfo();
    
    return {
      isAuthenticated: authService.isAuthenticated(),
      needsRefresh: authService.needsTokenRefresh(),
      timeToExpiry: authService.getTokenTimeToExpiry(),
      hasToken: !!localStorage.getItem('accessToken'),
      tokenType: localStorage.getItem('tokenType'),
      expiresIn: localStorage.getItem('expiresIn'),
      tokenExpiryTime: tokenExpiryTime ? new Date(parseInt(tokenExpiryTime)).toISOString() : null,
      tokenCreatedAt: tokenCreatedAt ? new Date(parseInt(tokenCreatedAt)).toISOString() : null,
      scope: localStorage.getItem('scope'),
      user: authService.getStoredUser(),
      refreshToken: refreshTokenDebug,
      sessionData: {
        oauth_state: sessionStorage.getItem('oauth_state'),
        silent_oauth_state: sessionStorage.getItem('silent_oauth_state'),
        oauth_popup_mode: sessionStorage.getItem('oauth_popup_mode')
      },
      tokenRefreshManager: tokenRefreshManager.getRefreshStatus()
    };
  },

  /**
   * ID Token Í≤ÄÏ¶ù (OIDC)
   */
  validateIDToken: async (idToken: string): Promise<IDTokenClaims> => {
    try {
      // ÌÜ†ÌÅ∞ ÎîîÏΩîÎìú (ÏÑúÎ™Ö Í≤ÄÏ¶ùÏùÄ Î∞±ÏóîÎìúÏóêÏÑú)
      const claims = jwtDecode<IDTokenClaims>(idToken);
      
      // Í∏∞Î≥∏ Í≤ÄÏ¶ù
      const now = Math.floor(Date.now() / 1000);
      
      // ÎßåÎ£å ÏãúÍ∞Ñ Í≤ÄÏ¶ù
      if (claims.exp && claims.exp < now) {
        throw new Error('ID Token has expired');
      }
      
      // Î∞úÍ∏â ÏãúÍ∞Ñ Í≤ÄÏ¶ù (ÎÑàÎ¨¥ Ïò§ÎûòÎêú ÌÜ†ÌÅ∞ Í±∞Î∂Ä)
      if (claims.iat && claims.iat > now + 60) { // 1Î∂Ñ Ïù¥ÏÉÅ ÎØ∏Îûò
        throw new Error('ID Token issued in the future');
      }
      
      // Nonce Í≤ÄÏ¶ù
      const storedNonce = sessionStorage.getItem('oauth_nonce');
      if (storedNonce && claims.nonce !== storedNonce) {
        throw new Error('Invalid nonce in ID Token');
      }
      
      // Audience Í≤ÄÏ¶ù
      const clientId = import.meta.env.VITE_CLIENT_ID || 'maxlab';
      if (claims.aud !== clientId) {
        throw new Error('Invalid audience in ID Token');
      }
      
      // Issuer Í≤ÄÏ¶ù
      const expectedIssuer = import.meta.env.VITE_AUTH_SERVER_URL || 'http://localhost:8000';
      if (!claims.iss || !claims.iss.startsWith(expectedIssuer)) {
        throw new Error('Invalid issuer in ID Token');
      }
      
      // Í≤ÄÏ¶ù ÏÑ±Í≥µ ÌõÑ nonce Ï†ïÎ¶¨
      sessionStorage.removeItem('oauth_nonce');
      
      return claims;
    } catch (error: any) {
      console.error('ID Token validation error:', error);
      throw new Error(`ID Token validation failed: ${error.message}`);
    }
  },

  /**
   * Generate PKCE code verifier for OAuth flows
   */
  generateCodeVerifier(): string {
    const array = new Uint8Array(32);
    crypto.getRandomValues(array);
    return btoa(String.fromCharCode(...array))
      .replace(/\+/g, '-')
      .replace(/\//g, '_')
      .replace(/=/g, '');
  },

  /**
   * Generate nonce for OIDC flows
   */
  generateNonce(): string {
    const array = new Uint8Array(32);
    crypto.getRandomValues(array);
    return Array.from(array, byte => byte.toString(16).padStart(2, '0')).join('');
  }
};